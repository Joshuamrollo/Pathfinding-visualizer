{"version":3,"sources":["Pathfinding/Algorithms/Dijkstras.js","Pathfinding/Algorithms/DepthFirstSearch.js","Pathfinding/Algorithms/Astar.js","Pathfinding/Algorithms/RecursiveBacktracking.js","Pathfinding/Node/Node.js","Pathfinding/Pathfinding.js","Pathfinding/Algorithms/BreadthFirstSearch.js","App.js","index.js"],"names":["dijkstras","nodes","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","grid","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unVisitedNeighbors","neighbors","col","filter","neighbor","getUnvisitedNeighbors","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","depthFirstSearch","dfs","previous","found","isFinish","dir","calculateManhattanDistance","endNode","currentRow","currentCol","endRow","endCol","Math","abs","getNeighboringNodes","numRows","numCols","MinHeap","array","this","nodePositionsInHeap","reduce","obj","i","id","heap","buildHeap","currentIdx","floor","siftDown","endIdx","childOneIdx","childTwoIdx","idxToSwap","estimatedDistanceToEnd","swap","parentIdx","isEmpty","pop","siftUp","j","temp","RecursiveBacktracking","mazeNodesInOrder","backtracking","directions","num","random","roll","splice","invalidRow","invalidCol","check","checkUp","checkRight","checkDown","checkLeft","checkAvailable","targetNode","Node","props","isStart","isPath","onMouseDown","onMouseEnter","onMouseUp","extraClassName","className","Component","START_ROW","START_COL","END_ROW","END_COL","Pathfinding","useState","setNodes","mouseIsPressed","setMouseIsPressed","hasLoaded","setHasLoaded","algorithm","SetAlgorithm","useEffect","emptyBoard","createNode","toString","handleMouseUp","AddWall","newNodes","slice","newNode","animateBfs","start","finish","queue","current","breadthFirstSearch","setTimeout","animateShortestPath","document","getElementById","animateAstar","nodesToVisit","currentMinDistanceNode","remove","tentativeDistanceToNeighbor","containsNode","update","insert","Astar","setAllNodesToWalls","visualizeAlgorithm","animateDfs","animateDijkstras","onClick","console","log","animateRecursiveBacktracking","value","onChange","e","target","handleDropdown","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","App","Helmet","ReactDOM","render"],"mappings":"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","file":"static/js/main.ebdc7239.chunk.js","sourcesContent":["export function dijkstras(nodes, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(nodes);\r\n    while(!!unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.isWall) continue;\r\n        if(closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, nodes);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, nodes) {\r\n    const unVisitedNeighbors = getUnvisitedNeighbors(node, nodes);\r\n    for(const neighbor of unVisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if(row > 0) neighbors.push(grid[row - 1][col]);\r\n    if(row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col - 1]);\r\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid){\r\n        for (const node of row){\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode){\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode != null){\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}","export function depthFirstSearch(nodes, row, col){\r\n    let visitedNodesInOrder = [];\r\n\r\n    dfs(nodes, row, col, visitedNodesInOrder, null, false);\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction dfs(nodes, row, col, visitedNodesInOrder, previous, found){\r\n    let directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\r\n\r\n    if(row < 0 || row >= nodes.length || col < 0 || col >= nodes[0].length){\r\n        return;\r\n    }else if(nodes[row][col].isVisited || nodes[row][col].isWall){\r\n        return;\r\n    }\r\n\r\n    nodes[row][col].previousNode = previous;\r\n    nodes[row][col].isVisited = true;\r\n    if(nodes[row][col].isFinish) found = true;\r\n\r\n    visitedNodesInOrder.push(nodes[row][col]);\r\n\r\n    for(let dir of directions){\r\n        if(!found){\r\n            found = dfs(nodes, row + dir[0], col + dir[1], visitedNodesInOrder, nodes[row][col], found);\r\n        }\r\n    }\r\n    return found;\r\n}","export function Astar(startNode, endNode, nodes) {\r\n    const visitedNodesInOrder = [];\r\n      \r\n    startNode.distance = 0;\r\n    startNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode);\r\n      \r\n    const nodesToVisit = new MinHeap([startNode]);\r\n      \r\n    while(!nodesToVisit.isEmpty()){\r\n        const currentMinDistanceNode = nodesToVisit.remove();\r\n        visitedNodesInOrder.push(currentMinDistanceNode);\r\n\r\n        if(currentMinDistanceNode === endNode) break;\r\n          \r\n        const neighbors = getNeighboringNodes(currentMinDistanceNode, nodes);\r\n        for(const neighbor of neighbors) {\r\n            if(neighbor.isWall === true) continue;\r\n              \r\n            const tentativeDistanceToNeighbor = currentMinDistanceNode.distance + 1;\r\n          \r\n            if(tentativeDistanceToNeighbor >= neighbor.distance) continue;\r\n          \r\n            neighbor.previousNode = currentMinDistanceNode;\r\n            neighbor.distance = tentativeDistanceToNeighbor;\r\n            neighbor.estimatedDistanceToEnd = tentativeDistanceToNeighbor + calculateManhattanDistance(neighbor, endNode);\r\n            \r\n            if(!nodesToVisit.containsNode(neighbor)) {\r\n                nodesToVisit.insert(neighbor);\r\n            } else {\r\n                nodesToVisit.update(neighbor);\r\n            }\r\n        }\r\n    }\r\n      \r\n    return visitedNodesInOrder;\r\n}\r\n  \r\nfunction calculateManhattanDistance(currentNode, endNode){\r\n    const currentRow = currentNode.row;\r\n    const currentCol = currentNode.col;\r\n    const endRow = endNode.row;\r\n    const endCol = endNode.col;\r\n      \r\n    return Math.abs(currentRow - endRow) + Math.abs(currentCol - endCol);\r\n}\r\n  \r\nfunction getNeighboringNodes(node, nodes){\r\n    const neighbors = [];\r\n      \r\n    const numRows = nodes.length;\r\n    const numCols = nodes[0].length;\r\n      \r\n    const row = node.row;\r\n    const col = node.col;\r\n      \r\n    if(row < numRows - 1) {\r\n        neighbors.push(nodes[row + 1][col]);\r\n    }\r\n      \r\n    if(row > 0){\r\n        neighbors.push(nodes[row - 1][col]);\r\n    }\r\n      \r\n    if(col < numCols - 1) {\r\n        neighbors.push(nodes[row][col + 1]);\r\n    }\r\n      \r\n    if(col > 0){\r\n        neighbors.push(nodes[row][col - 1]);\r\n    }\r\n      \r\n    return neighbors;\r\n}\r\n  \r\nclass MinHeap {\r\n    constructor(array) {\r\n        this.nodePositionsInHeap = array.reduce((obj, node, i) => {\r\n            obj[node.id] = i;\r\n            return obj;\r\n        }, {});\r\n        this.heap = this.buildHeap(array);\r\n    }\r\n      \r\n    isEmpty() {\r\n        return this.heap.length === 0;\r\n    }\r\n      \r\n    buildHeap(array){\r\n        const firstParentIdx = Math.floor((array.length - 2) / 2);\r\n        for(let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\r\n            this.siftDown(currentIdx, array.length - 1, array);\r\n        }\r\n        return array;\r\n    }\r\n      \r\n    siftDown(currentIdx, endIdx, heap){\r\n        let childOneIdx = currentIdx * 2 + 1;\r\n        while(childOneIdx <= endIdx) {\r\n            const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\r\n            let idxToSwap;\r\n            if(childTwoIdx !== -1 && heap[childTwoIdx].estimatedDistanceToEnd < heap[childOneIdx].estimatedDistanceToEnd) {\r\n                idxToSwap = childTwoIdx;\r\n            } else{\r\n                idxToSwap = childOneIdx;\r\n            }\r\n            if(heap[idxToSwap].estimatedDistanceToEnd < heap[currentIdx].estimatedDistanceToEnd) {\r\n                this.swap(currentIdx, idxToSwap, heap);\r\n                currentIdx = idxToSwap;\r\n                childOneIdx = currentIdx * 2 + 1;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n      \r\n    siftUp(currentIdx, heap){\r\n        let parentIdx = Math.floor((currentIdx - 1) / 2);\r\n        while(currentIdx > 0 && heap[currentIdx].estimatedDistanceToEnd < heap[parentIdx].estimatedDistanceToEnd) {\r\n            this.swap(currentIdx, parentIdx, heap);\r\n            currentIdx = parentIdx;\r\n            parentIdx = Math.floor((currentIdx - 1) / 2);\r\n        }\r\n    }\r\n      \r\n    remove() {\r\n        if(this.isEmpty()) return;\r\n          \r\n        this.swap(0, this.heap.length - 1, this.heap);\r\n        const node = this.heap.pop();\r\n        delete this.nodePositionsInHeap[node.id];\r\n        this.siftDown(0, this.heap.length - 1, this.heap);\r\n        return node;\r\n    }\r\n      \r\n    insert(node) {\r\n        this.heap.push(node);\r\n        this.nodePositionsInHeap[node.id] = this.heap.length - 1;\r\n        this.siftUp(this.heap.length - 1, this.heap);\r\n    }\r\n      \r\n    swap(i, j, heap){\r\n        this.nodePositionsInHeap[this.heap[i].id] = j;\r\n        this.nodePositionsInHeap[this.heap[j].id] = i;\r\n        const temp = heap[j];\r\n        heap[j] = heap[i];\r\n        heap[i] = temp;\r\n    }\r\n      \r\n    containsNode(node){\r\n        return node.id in this.nodePositionsInHeap;\r\n    }\r\n      \r\n    update(node){\r\n        this.siftUp(this.nodePositionsInHeap[node.id], this.heap);\r\n    }\r\n}","export function RecursiveBacktracking(endNode, nodes){\r\n    let mazeNodesInOrder = [];\r\n    [mazeNodesInOrder, nodes] = backtracking(endNode, nodes, mazeNodesInOrder);\r\n    return [mazeNodesInOrder, nodes];\r\n}\r\n\r\nfunction backtracking(currentNode, nodes, mazeNodesInOrder){\r\n    let directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\r\n\r\n    currentNode.isWall = false;\r\n    mazeNodesInOrder.push(currentNode);\r\n\r\n    let dir = [0,1,2,3];\r\n\r\n    do{\r\n        let num = Math.floor(Math.random() * dir.length);\r\n        let roll = dir.splice(num, 1);\r\n\r\n        const invalidRow = currentNode.row + directions[roll[0]][0] >= nodes.length - 1 || currentNode.row + directions[roll[0]][0] < 1;\r\n        const invalidCol = currentNode.col + directions[roll[0]][1] >= nodes[0].length - 1 || currentNode.col + directions[roll[0]][1] < 1;\r\n        if(invalidRow || invalidCol) continue;\r\n        if(!nodes[currentNode.row + directions[roll[0]][0]][currentNode.col + directions[roll[0]][1]].isWall) continue;\r\n        let check = true;\r\n        if(roll[0] === 0) check = checkUp(nodes[currentNode.row + directions[roll[0]][0]][currentNode.col + directions[roll[0]][1]], nodes);\r\n        if(roll[0] === 1) check = checkRight(nodes[currentNode.row + directions[roll[0]][0]][currentNode.col + directions[roll[0]][1]], nodes);\r\n        if(roll[0] === 2) check = checkDown(nodes[currentNode.row + directions[roll[0]][0]][currentNode.col + directions[roll[0]][1]], nodes);\r\n        if(roll[0] === 3) check = checkLeft(nodes[currentNode.row + directions[roll[0]][0]][currentNode.col + directions[roll[0]][1]], nodes);\r\n        if(!check) continue;\r\n        let isAvailable = checkAvailable(currentNode, nodes[currentNode.row + directions[roll[0]][0]][currentNode.col + directions[roll[0]][1]], nodes);\r\n        if(!isAvailable) continue;\r\n        [mazeNodesInOrder, nodes] = backtracking(nodes[currentNode.row + directions[roll[0]][0]][currentNode.col + directions[roll[0]][1]], nodes, mazeNodesInOrder);\r\n    }while(dir.length > 0);\r\n    return [mazeNodesInOrder, nodes];\r\n}\r\n\r\nfunction checkAvailable(currentNode, targetNode, nodes){\r\n    let directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\r\n    for(let dir of directions){\r\n        const invalidRow = targetNode.row + dir[0] >= nodes.length || targetNode.row + dir[0] < 0;\r\n        const invalidCol = targetNode.col + dir[1] >= nodes[0].length || targetNode.col + dir[1] < 0;\r\n        if(!invalidRow && !invalidCol){\r\n            if(!nodes[targetNode.row + dir[0]][targetNode.col + dir[1]].isWall && nodes[targetNode.row + dir[0]][targetNode.col + dir[1]] !== currentNode){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction checkUp(targetNode, nodes){\r\n    let directions = [[1, 1], [-1, 1]];\r\n    for(let dir of directions){\r\n        const invalidRow = targetNode.row + dir[0] >= nodes.length || targetNode.row + dir[0] < 0;\r\n        const invalidCol = targetNode.col + dir[1] >= nodes[0].length || targetNode.col + dir[1] < 0;\r\n        if(!invalidRow && !invalidCol){\r\n            if(!nodes[targetNode.row + dir[0]][targetNode.col + dir[1]].isWall){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction checkRight(targetNode, nodes){\r\n    let directions = [[1, 1], [1, -1]];\r\n    for(let dir of directions){\r\n        const invalidRow = targetNode.row + dir[0] >= nodes.length || targetNode.row + dir[0] < 0;\r\n        const invalidCol = targetNode.col + dir[1] >= nodes[0].length || targetNode.col + dir[1] < 0;\r\n        if(!invalidRow && !invalidCol){\r\n            if(!nodes[targetNode.row + dir[0]][targetNode.col + dir[1]].isWall){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction checkDown(targetNode, nodes){\r\n    let directions = [[1, -1], [-1, -1]];\r\n    for(let dir of directions){\r\n        const invalidRow = targetNode.row + dir[0] >= nodes.length || targetNode.row + dir[0] < 0;\r\n        const invalidCol = targetNode.col + dir[1] >= nodes[0].length || targetNode.col + dir[1] < 0;\r\n        if(!invalidRow && !invalidCol){\r\n            if(!nodes[targetNode.row + dir[0]][targetNode.col + dir[1]].isWall){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction checkLeft(targetNode, nodes){\r\n    let directions = [[-1, -1], [-1, 1]];\r\n    for(let dir of directions){\r\n        const invalidRow = targetNode.row + dir[0] >= nodes.length || targetNode.row + dir[0] < 0;\r\n        const invalidCol = targetNode.col + dir[1] >= nodes[0].length || targetNode.col + dir[1] < 0;\r\n        if(!invalidRow && !invalidCol){\r\n            if(!nodes[targetNode.row + dir[0]][targetNode.col + dir[1]].isWall){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    render() {\r\n        const {\r\n            col,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            isVisited,\r\n            isPath,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row,\r\n        } = this.props;\r\n        const extraClassName = isFinish ? 'node-finish' : isStart ? 'node-start' : isWall ? 'node-wall' : isVisited? 'node-visited' : isPath? 'node-shortest-path': '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}\r\n            ></div>\r\n        )\r\n    }\r\n}","import React, {useState, useEffect} from 'react';\r\nimport { dijkstras, getNodesInShortestPathOrder } from './Algorithms/Dijkstras';\r\nimport { depthFirstSearch } from './Algorithms/DepthFirstSearch';\r\nimport { breadthFirstSearch } from './Algorithms/BreadthFirstSearch';\r\nimport { Astar } from './Algorithms/Astar';\r\nimport { RecursiveBacktracking } from './Algorithms/RecursiveBacktracking';\r\nimport Node from './Node/Node';\r\n\r\nimport './Pathfinding.css';\r\n\r\nconst START_ROW = 13;\r\nconst START_COL = 20;\r\nconst END_ROW = 13;\r\nconst END_COL = 50;\r\n\r\nfunction Pathfinding() {\r\n    const [nodes, setNodes] = useState([]);\r\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n    const [hasLoaded, setHasLoaded] = useState(false);\r\n    const [algorithm, SetAlgorithm] = useState('Breadth First Search');\r\n    //const [animating, setAnimating] = useState(false);\r\n    \r\n\r\n    useEffect(() => {\r\n        const emptyBoard = [];\r\n        for(let row = 0; row < 29; row++){\r\n            const currentRow = [];\r\n            for(let col = 0; col< 73; col++){\r\n                currentRow.push(createNode(col, row));\r\n            }\r\n            emptyBoard.push(currentRow);\r\n        }\r\n        setNodes(emptyBoard);\r\n        setHasLoaded(true);\r\n    }, []); // eslint-disable-line react-hooks/exhaustive-deps\r\n\r\n    const emptyBoard = () => {\r\n        const emptyBoard = [];\r\n        for(let row = 0; row < 29; row++){\r\n            const currentRow = [];\r\n            for(let col = 0; col< 73; col++){\r\n                currentRow.push(createNode(col, row));\r\n                if(col === START_COL && row === START_ROW){\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n                }else if(col === END_COL && row === END_ROW){\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n                }else{\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                }\r\n            }\r\n            emptyBoard.push(currentRow);\r\n        }\r\n        setNodes(emptyBoard);\r\n    }\r\n\r\n    const createNode = (col, row) => {\r\n        return {\r\n            col,\r\n            row,\r\n            id: row.toString() + '-' + col.toString(),\r\n            isStart: row === START_ROW && col === START_COL,\r\n            isFinish: row === END_ROW && col === END_COL,\r\n            distance: Infinity,\r\n            estimatedDistanceToEnd: Infinity,\r\n            isVisited: false,\r\n            isPath: false,\r\n            isWall: false,\r\n            previousNode: null,\r\n        }\r\n    }\r\n\r\n    const handleMouseDown = (row, col) => {\r\n        const newNodes = AddWall(nodes, row, col);\r\n        setMouseIsPressed(true);\r\n        setNodes(newNodes);\r\n    }\r\n\r\n    const handleMouseEnter = (row, col) => {\r\n        if(mouseIsPressed) {\r\n            const newNodes = AddWall(nodes, row, col);\r\n            setNodes(newNodes);\r\n        }\r\n    }\r\n\r\n    const handleMouseUp = () => {\r\n        setMouseIsPressed(false);\r\n    }\r\n\r\n    const AddWall = (nodes, row, col) => {\r\n        const newNodes = nodes.slice();\r\n        const node = newNodes[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        newNodes[row][col] = newNode;\r\n        return newNodes;\r\n    }\r\n\r\n    const animateDijkstras = () => {\r\n        const start = nodes[START_ROW][START_COL];\r\n        const finish = nodes[END_ROW][END_COL];\r\n        nodes[START_ROW][START_COL].isWall = false;\r\n        const visitedNodesInOrder = dijkstras(nodes, start, finish);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finish);\r\n        for(let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if(i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n                node.isVisited = true;\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    const animateDfs = () => {\r\n        const finish = nodes[END_ROW][END_COL];\r\n        nodes[START_ROW][START_COL].isWall = false;\r\n        const visitedNodesInOrder = depthFirstSearch(nodes, START_ROW, START_COL);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finish);\r\n        for(let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if(i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n                node.isVisited = true;\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    const animateBfs = () => {\r\n        const start = nodes[START_ROW][START_COL];\r\n        const finish = nodes[END_ROW][END_COL];\r\n        nodes[START_ROW][START_COL].isWall = false;\r\n        const visitedNodesInOrder = breadthFirstSearch(nodes, start);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finish);\r\n        for(let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if(i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n                node.isVisited = true;\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    const animateAstar = () => {\r\n        const start = nodes[START_ROW][START_COL];\r\n        const finish = nodes[END_ROW][END_COL];\r\n        nodes[START_ROW][START_COL].isWall = false;\r\n        const visitedNodesInOrder = Astar(start, finish, nodes);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finish);\r\n        for(let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if(i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n                node.isVisited = true;\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    const animateShortestPath = (nodesInShortestPathOrder) => {\r\n        for(let i = 0; i < nodesInShortestPathOrder.length; i++){\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\r\n                node.isPath = true;\r\n            }, 25 * i);\r\n        }\r\n    }\r\n\r\n    const animateRecursiveBacktracking = () => {\r\n        const finish = nodes[END_ROW][END_COL];\r\n        let wallNodes = setAllNodesToWalls();\r\n        let [mazeNodesInOrder, newNodes] = RecursiveBacktracking(finish, wallNodes);\r\n        console.log(mazeNodesInOrder);\r\n        setNodes(newNodes);\r\n    }\r\n\r\n    const setAllNodesToWalls = () => {\r\n        let newNodes = [...nodes];\r\n        for(let row of newNodes){\r\n            for(let node of row){\r\n                node.isWall = true;\r\n            }\r\n        }\r\n        return newNodes;\r\n    }\r\n\r\n    const handleDropdown = (e) => {\r\n        SetAlgorithm(e.target.value);\r\n    }\r\n\r\n    const visualizeAlgorithm = () => {\r\n        if(algorithm === 'Depth First Search')animateDfs();\r\n        if(algorithm === 'Breadth First Search')animateBfs();\r\n        if(algorithm === 'Dijkstras')animateDijkstras();\r\n        if(algorithm === 'A Star')animateAstar();\r\n    }\r\n\r\n    return hasLoaded ? (\r\n        <div className='main-container'>\r\n            <div className='navbar'>\r\n                <div className='title'>Pathfinding Visualizer</div>\r\n                <div className='nav-items'>\r\n                    <button onClick={() => animateRecursiveBacktracking()} className='maze'>Generate Maze</button>\r\n                    <select className='dropdown' value={algorithm} onChange={(e) => handleDropdown(e)}>\r\n                        <option value='Dijkstras' className='options'>Dijkstras</option>\r\n                        <option value='Depth First Search' className='options'>Depth First Search</option>\r\n                        <option value='Breadth First Search' className='options'>Breadth First Search</option>\r\n                        <option value='A Star' className='options'>A Star</option>\r\n                    </select>\r\n                    <button onClick={() => visualizeAlgorithm()} className='visualize'>Visualize Algorithm</button>\r\n                    <button onClick={() => emptyBoard()} className='empty'>EmptyBoard</button>\r\n                </div>\r\n            </div>\r\n            <div className='board'>\r\n                {nodes.map((row, rowIdx) => {\r\n                    return(\r\n                        <div key={rowIdx}>\r\n                            {row.map((node, nodeIdx) => {\r\n                                return(<Node\r\n                                    key={nodeIdx}\r\n                                    row={node.row}\r\n                                    col={node.col}\r\n                                    isStart={node.isStart}\r\n                                    isFinish={node.isFinish}\r\n                                    isWall={node.isWall}\r\n                                    isVisited={node.isVisited}\r\n                                    isPath={node.isPath}\r\n                                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\r\n                                    onMouseUp={handleMouseUp}\r\n                                    ></Node>)\r\n                            })}\r\n                        </div>    \r\n                    )\r\n                })}\r\n            </div>\r\n        </div>\r\n    ) : (<div>loading</div>)\r\n}\r\n\r\nexport default Pathfinding;\r\n","export function breadthFirstSearch(nodes, start){\r\n    let directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\r\n    const visitedNodesInOrder = [];\r\n    const queue = [start];\r\n    let found = false;\r\n    while(queue.length > 0 && !found){\r\n        const current = queue[0];\r\n        queue.shift();\r\n        visitedNodesInOrder.push(current);\r\n        current.isVisited = true;\r\n        if(current.isFinish){\r\n            found = true;\r\n            return visitedNodesInOrder;\r\n        }\r\n        for(const dir of directions){\r\n            const invalidRow = current.row + dir[0] >= nodes.length || current.row + dir[0] < 0;\r\n            const invalidCol = current.col + dir[1] >= nodes[0].length || current.col + dir[1] < 0;\r\n            if(!invalidRow && !invalidCol){\r\n                if(!nodes[current.row + dir[0]][current.col + dir[1]].isWall && !nodes[current.row + dir[0]][current.col + dir[1]].isVisited){\r\n                    queue.push(nodes[current.row + dir[0]][current.col + dir[1]]);\r\n                    nodes[current.row + dir[0]][current.col + dir[1]].isVisited = true;\r\n                    nodes[current.row + dir[0]][current.col + dir[1]].previousNode = current;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}","import Pathfinding from './Pathfinding/Pathfinding';\nimport {Helmet} from 'react-helmet';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Helmet>\n        <title>Pathfinding Visualizer</title>\n      </Helmet>\n      <Pathfinding />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(<App />,document.getElementById('root'));\n\n"],"sourceRoot":""}